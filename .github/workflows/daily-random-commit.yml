name: Daily Random Commit

# Schedule + manual run
on:
  schedule:
    - cron: '0 12 * * *'   # daily at 12:00 UTC — adjust if needed
  workflow_dispatch:       # allow manual trigger from Actions

permissions:
  contents: write          # required to push changes

jobs:
  random-commit:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true   # push using GITHUB_TOKEN

      - name: Create folder if needed
        run: mkdir -p automated_changes

      - name: Randomize timing (optional jitter)
        env:
          EVENT_NAME: ${{ github.event_name }}
        run: |
          # Skip delay on manual run to avoid waiting during verification
          if [ "$EVENT_NAME" = "workflow_dispatch" ]; then
            echo "Skipping jitter for manual run"
            JITTER=0
          else
            # Sleep random time up to ~30 minutes to avoid same-time commits
            JITTER=$((RANDOM % 1800))
            echo "Sleeping for $JITTER seconds to add timing jitter..."
            sleep $JITTER
          fi

      - name: Generate random change
        run: |
          FILE="automated_changes/random_change.txt"
          TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          # random alnum string
          RANDOM_STR=$(head /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c 12)
          # add a simple line in English
          LINE="Note ${RANDOM_STR} at ${TIMESTAMP}"
          echo "$LINE" >> "$FILE"
          echo "Generated: $LINE"

      - name: Prepare commit message (English only + external file)
        id: prepmsg
        run: |
          FILE_DEFAULT="automated_changes/messages.txt"
          FILE_EN="automated_changes/messages-en.txt"

          pick_from_file() {
            local F="$1"
            if [ -s "$F" ]; then
              # read non-empty lines as options
              mapfile -t LINES < <(sed 's/\r$//' "$F" | awk 'NF>0')
              if [ ${#LINES[@]} -gt 0 ]; then
                local IDX=$((RANDOM % ${#LINES[@]}))
                echo "${LINES[$IDX]}"
                return 0
              fi
            fi
            return 1
          }

          # Try English-specific file first, then generic file
          MSG=$(pick_from_file "$FILE_EN" || true)
          if [ -z "$MSG" ]; then MSG=$(pick_from_file "$FILE_DEFAULT" || true); fi

          # Fallback to built-in English list if files are missing
          if [ -z "$MSG" ]; then
              msgs=(
                "Docs: minor notes"
                "Notes: update log"
                "Chore: housekeeping"
                "Maintenance update"
                "Update timestamp"
                "Small tweaks"
                "Adjust notes"
                "Misc: keep notes fresh"
                "Refresh notes"
                "Routine update"
                "Editorial: tiny wording"
                "Polish: small cleanup"
                "Meta: notes refresh"
                "Record today’s note"
              )
            MSG_IDX=$((RANDOM % ${#msgs[@]}))
            MSG="${msgs[$MSG_IDX]}"
          fi

          NOW=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          echo "COMMIT_MSG=$MSG ($NOW)" >> "$GITHUB_OUTPUT"

      - name: Show git status (for logs)
        run: git status --porcelain && git --no-pager log -1 --pretty=oneline || true

      - name: Configure Git user (as repository owner or provided secrets)
        env:
          OWNER: ${{ github.repository_owner }}
          SECRET_NAME: ${{ secrets.GIT_AUTHOR_NAME }}
          SECRET_EMAIL: ${{ secrets.GIT_AUTHOR_EMAIL }}
        run: |
          # Use secrets GIT_AUTHOR_NAME/EMAIL if provided, otherwise fall back to owner noreply address
          NAME="${SECRET_NAME:-$OWNER}"
          EMAIL="${SECRET_EMAIL:-$OWNER@users.noreply.github.com}"

          echo "Using commit author: $NAME <$EMAIL>"

          git config user.name "$NAME"
          git config user.email "$EMAIL"

          # Also export author/committer env vars (just in case)
          export GIT_AUTHOR_NAME="$NAME"
          export GIT_AUTHOR_EMAIL="$EMAIL"
          export GIT_COMMITTER_NAME="$NAME"
          export GIT_COMMITTER_EMAIL="$EMAIL"

      - name: Commit and push changes to default branch
        env:
          PREPARED_MSG: ${{ steps.prepmsg.outputs.COMMIT_MSG }}
        run: |
          git add automated_changes/random_change.txt
          # commit only if there are changes
          if git diff --cached --quiet; then
            echo "Nothing to commit"
          else
            # Use prepared message (from external file or fallback list)
            COMMIT_MSG="${PREPARED_MSG}"
            if [ -z "$COMMIT_MSG" ]; then
              NOW=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
              COMMIT_MSG="Maintenance update ($NOW)"
            fi
            git commit -m "$COMMIT_MSG"
            # Push explicitly to the checked-out branch (usually default branch)
            CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
            echo "Pushing to $CURRENT_BRANCH"
            git push origin "$CURRENT_BRANCH"
            echo "Pushed commit: $COMMIT_MSG"
          fi
